[
  {
    "objectID": "pages/400-alignment.html",
    "href": "pages/400-alignment.html",
    "title": "Multiple Alignment Sequences",
    "section": "",
    "text": "Multiple Sequence Alignments are a collection of multiple sequences which have been aligned together, usually with the insertion of gap characters, such that all the sequence strings are the same length. Alignment can be regarded as a matrix of letters, where each row is held as a SeqRecord object internally.\nThe MultipleSeqAlignment object holds this kind of data, and the AlignIO module is used for reading and writing them as various file formats.\nThe detail API of the AlignIO module\n\n\n\n\n\n\nAlignment files\n\n\n\nThis example shows an alignment of two sequences in FASTA format. The sequences are aligned with inserted gaps, represented by the - character.\n&gt;seq1\nTCACTCTTTGGCAACGACCCGTCGTCATAATAAAGATAGAGGGGCAACTAAAGGAAGCTCTA\nTTAGATACAGGAGCAGATGATACAGTATTAGAAGAAAT\n\n&gt;seq2\nTCACTCTTTGGCAAC---GCGTCGTCACAATAAAGATAGAGGGGCAACTAAAGGAAGCTCTA\nTTAGATACAGGAGCAGATGATACAGTATTAGAAGAAAT\n\n\n\nFiles for this section\nFor this section you need to download some files which we will be reading in. You can either download them by hand from using these links: PF05371_seed.sth and dummy_aln.phy or run the following Python code:\nimport urllib\nfor f in [\"PF05371_seed.sth\", \"dummy_aln.phy\"]:\n    urllib.request.urlretrieve(f\"https://bristol-training.github.io/introduction-to-biopython/data/{f}\", f)\n\n\nParsing or Reading Sequence Alignments\nMuch like SeqIO, AlignIO contains 2 functions for reading in sequence alignments:\n\nread() - will return a single MultipleSeqAlignment object\nparse() - will return an iterator which gives MultipleSeqAlignment objects\n\nBoth functions expect two mandatory arguments:\n\nA string specifying a handle to an open file or a filename.\nA lower case string specifying the alignment format. See here for a full listing of supported formats.\n\n\nSingle alignments\nLet’s start with a single alignments file which contains the seed alignment for the Phage_Coat_Gp8 (PF05371) PFAM entry. The file contains a lot of annotation information but let’s just go ahead and load it in to see how it looks:\n\nfrom Bio import AlignIO\naln_seed = AlignIO.read(\"data/PF05371_seed.sth\", \"stockholm\")\nprint(aln_seed)\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 from Bio import AlignIO\n      2 aln_seed = AlignIO.read(\"data/PF05371_seed.sth\", \"stockholm\")\n      3 print(aln_seed)\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\nNote in the above output the sequences have been elided in the middle (...). We could instead write our own code to format this as we please by iterating over the rows as SeqRecord objects and printing the first 50 values of each sequence:\n\nfor record in aln_seed:\n    print(f\"{record.seq[:50]} - {record.id}\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 for record in aln_seed:\n      2     print(f\"{record.seq[:50]} - {record.id}\")\n\nNameError: name 'aln_seed' is not defined\n\n\n\nWith any supported file format, we can load an alignment in exactly the same way just by changing the format string. For example, use \"phylip\" for PHYLIP files, \"nexus\" for NEXUS files or \"emboss\" for the alignments output by the EMBOSS tools.\n\n\nMultiple Alignments\nIn general alignment files can contain multiples alignments, and to read these files we must use the AlignIO.parse function.\nWe have previously downloaded a file called dummy_aln.phy which contains some dummy alignment information in PHYLIP format. If we wanted to read this in using AlignIO we could use:\n\naln_dummy = AlignIO.parse(\"data/dummy_aln.phy\", \"phylip\")\nfor alignment in aln_dummy:\n    print(alignment)\n    print(\"---\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 aln_dummy = AlignIO.parse(\"data/dummy_aln.phy\", \"phylip\")\n      2 for alignment in aln_dummy:\n      3     print(alignment)\n\nNameError: name 'AlignIO' is not defined\n\n\n\nThe .parse() function returns an iterator. If we want to keep all the alignments in memory at once, then we need to turn the iterator into a list, just as we did with SeqIO.parse:\n\nalignments = list(AlignIO.parse(\"data/dummy_aln.phy\", \"phylip\"))\nsecond_aln = alignments[1]\nprint(second_aln)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 alignments = list(AlignIO.parse(\"data/dummy_aln.phy\", \"phylip\"))\n      2 second_aln = alignments[1]\n      3 print(second_aln)\n\nNameError: name 'AlignIO' is not defined\n\n\n\n\n\n\nWriting Alignments\nNow we’ll look at AlignIO.write() which is for alignments output (writing files).\nThis function takes 3 arguments: - Some MultipleSeqAlignment objects - A string specifying a handle or a filename to write to - A lower case string specifying the sequence format.\nWe start by creating a MultipleSeqAlignment object the hard way (by hand). Note we create some SeqRecord objects to construct the alignment from.\n\nfrom Bio.Align import MultipleSeqAlignment\n\nfrom Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\n\nalign1 = MultipleSeqAlignment([\n    SeqRecord(Seq(\"ACTGCTAGCTAG\"), id=\"toto\"),\n    SeqRecord(Seq(\"ACT-CTAGCTAG\"), id=\"titi\"),\n    SeqRecord(Seq(\"ACTGCTAGDTAG\"), id=\"tata\"),\n])\n\nprint(align1)\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 from Bio.Align import MultipleSeqAlignment\n      3 from Bio.Seq import Seq\n      4 from Bio.SeqRecord import SeqRecord\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\nNow let’s try to output, in PHYLIP format, these alignments in a file with the Phage_Coat_Gp8 alignments.\n\nmy_alignments = [align1, aln_seed]\nAlignIO.write(my_alignments, \"mixed.phy\", \"phylip\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 my_alignments = [align1, aln_seed]\n      2 AlignIO.write(my_alignments, \"mixed.phy\", \"phylip\")\n\nNameError: name 'align1' is not defined\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nRead in the alignment in PF05371_seed.sth and write it out in PHYLIP format.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfrom Bio import AlignIO\naln_pf05371 = list( AlignIO.parse(\"data/PF05371_seed.sth\", \"stockholm\") )\nAlignIO.write(aln_pf05371, \"pf05371.phy\", \"phylip\")\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 from Bio import AlignIO\n      2 aln_pf05371 = list( AlignIO.parse(\"data/PF05371_seed.sth\", \"stockholm\") )\n      3 AlignIO.write(aln_pf05371, \"pf05371.phy\", \"phylip\")\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\n\n\n\n\n\nExternal tools\nBiopython also has the ability to call out to lots of different external alignment tools including ClustalW, MUSCLE, EMBOSS, DIALIGN2-2, TCoffee and MSAProbs. Have a look at the classes in Bio.Align.Applications for more details.\nBy using the Biopython interfaces to these tools, you can build full pipelines in Python, making use of whatever tool is best for the particular job you want to do.",
    "crumbs": [
      "Multiple Alignment Sequences"
    ]
  },
  {
    "objectID": "pages/999-contributors.html",
    "href": "pages/999-contributors.html",
    "title": "Contributors",
    "section": "",
    "text": "This course was written by Matt Williams, see https://milliams.com/courses/intermediate_python/, based on the official Biopython tutorial. All text is published under a Creative Commons Attribution 4.0 International License with all code snippets licensed as MIT.\nThe alignment section was heavily based on the Concordia Python workshop by Mathieu Bourgey which is licensed with the Creative Commons Attribution-ShareAlike 3.0 Unported License.\nThe course has since been modified by the Jean Golding Institute.",
    "crumbs": [
      "Contributors"
    ]
  },
  {
    "objectID": "pages/990-summary.html",
    "href": "pages/990-summary.html",
    "title": "Summary",
    "section": "",
    "text": "This course has been an introduction to the tools that Biopython provides for doing bioinformatics. It is a very extensive tool suite so we would recommend you spending some time investigting what it can do.\nAn excellent starting point is the official Biopython tutorial.\nOther things to look in to:\n\nRunning BLAST locally or online with Bio.BLAST - tutorial chapter\nPhylogenetics with Bio.Phylo - tutorial chapter\nCluster analysis with Bio.Cluster - tutorial chapter",
    "crumbs": [
      "Summary"
    ]
  },
  {
    "objectID": "pages/500-databases.html",
    "href": "pages/500-databases.html",
    "title": "Online databases",
    "section": "",
    "text": "Biopython can work with many online resources. What follows here is a summary of some of the key points to start using online databases.\nThe Bio.Entrez module give you access from Python to the NCBI’s online databases. Before you start using it, there are a few things to be aware of:\n\nIt is recommended that for any series of more than 100 requests, do this at weekends or outside USA peak times.\nUse the email parameter so the NCBI can contact you if there is a problem. You can set a global email address:\n\nfrom Bio import Entrez\nEntrez.email = \"ab01234@bristol.ac.uk\"\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 from Bio import Entrez\n      2 Entrez.email = \"ab01234@bristol.ac.uk\"\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\n\n\nEInfo - Obtaining information about the Entrez databases\nLet’s start with the EInfo utility. This allows you to ask the service for its list of available databases:\nfrom Bio import Entrez\nEntrez.email = \"ab01234@bristol.ac.uk\"  # Always tell NCBI who you are\n\nhandle = Entrez.einfo()\nresult = Entrez.read(handle)\nprint(result[\"DbList\"])\n\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 handle = Entrez.einfo()\n      2 result = Entrez.read(handle)\n      3 print(result[\"DbList\"])\n\nNameError: name 'Entrez' is not defined\n\n\n\nWe can see, for example, the “pubmed”, “protein” and “nuccore” databases.\nYou can delve into any one of the databases individually by passing the name of it to the einfo function. For example, you can ask it for the valid list of query fields which we will be able to use shortly:\n\nhandle = Entrez.einfo(db=\"nucleotide\")\nresult = Entrez.read(handle)\n\nfor f in result[\"DbInfo\"][\"FieldList\"]:\n    print(f[\"Name\"], f[\"Description\"])\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 handle = Entrez.einfo(db=\"nucleotide\")\n      2 result = Entrez.read(handle)\n      4 for f in result[\"DbInfo\"][\"FieldList\"]:\n\nNameError: name 'Entrez' is not defined\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nLook at the database information for another database. What are the valid list of search fields there?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfrom Bio import Entrez\nEntrez.email = \"ab01234@bristol.ac.uk\" \n\nhandle = Entrez.einfo(db=\"pubmed\")\nresult = Entrez.read(handle)\n\nfor f in result[\"DbInfo\"][\"FieldList\"]:\n    print(f[\"Name\"], f[\"Description\"])\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 from Bio import Entrez\n      2 Entrez.email = \"ab01234@bristol.ac.uk\" \n      4 handle = Entrez.einfo(db=\"pubmed\")\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\n\n\n\n\n\nESearch - Searching the Entrez databases\nYou can also use ESearch to search GenBank. Here we’ll do a search for the matK gene in Cypripedioideae orchids. We specify the database we want to search, the search terms (based on the fields we found out about earlier) and pass the idtype argument to specify what we want to have returned as the .id field:\n\nhandle = Entrez.esearch(db=\"nucleotide\", term=\"Cypripedioideae[Orgn] AND matK[Gene]\", idtype=\"acc\")\nrecord = Entrez.read(handle)\nrecord[\"IdList\"]\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 handle = Entrez.esearch(db=\"nucleotide\", term=\"Cypripedioideae[Orgn] AND matK[Gene]\", idtype=\"acc\")\n      2 record = Entrez.read(handle)\n      3 record[\"IdList\"]\n\nNameError: name 'Entrez' is not defined\n\n\n\nEach of the IDs (NC_087860.1, PP503063.1, …) is a GenBank identifier (Accession number). We’ll see shortly how to actually download these GenBank records.\n\n\n\n\n\n\nExercise\n\n\n\nTry searching for another gene or organism and print its ID list. If you don’t know of another then just try replicating the code above.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhandle = Entrez.esearch(db=\"nucleotide\", term=\"homo sapiens[Orgn] AND tp53[Gene]\", idtype=\"acc\")\nrecord = Entrez.read(handle)\nrecord[\"IdList\"]\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 handle = Entrez.esearch(db=\"nucleotide\", term=\"homo sapiens[Orgn] AND tp53[Gene]\", idtype=\"acc\")\n      2 record = Entrez.read(handle)\n      3 record[\"IdList\"]\n\nNameError: name 'Entrez' is not defined\n\n\n\nHomo sapiens tumor protein p53 (TP53) NCBI Reference Sequence: NG_017013.2 https://www.ncbi.nlm.nih.gov/nuccore/383209646\n\n\n\n\n\nEFetch - Downloading full records from Entrez\nEFetch is what you use when you want to retrieve a full record from Entrez. This covers several possible databases, as described on the main EFetch help page.\nFor most of their databases, the NCBI support several different file formats. Requesting a specific file format from Entrez using Bio.Entrez.efetch requires specifying the rettype and/or retmode optional arguments. The different combinations are described for each database type on the pages linked to on NCBI efetch webpage.\nOne common usage is downloading sequences in the FASTA or GenBank/GenPept plain text formats (which can then be parsed with Bio.SeqIO). From the Cypripedioideae example above, we can download GenBank record NC_050871.1 using Bio.Entrez.efetch.\nWe specify the database we want to fetch from, the ID returned from the search, the return type of the data (FASTA, GenBank etc.) and that we want the result as plain text:\n\nhandle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 handle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\n\nNameError: name 'Entrez' is not defined\n\n\n\nThis has given us a handle which we can pass to Bio.SeqIO.read in place of the filename:\n\nfrom Bio import SeqIO\nSeqIO.read(handle, \"genbank\")\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 from Bio import SeqIO\n      2 SeqIO.read(handle, \"genbank\")\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\nIf you want to download the file and save a copy of it on disk, you can write the result to file with:\n\nhandle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\nrecord = SeqIO.read(handle, \"genbank\")\nSeqIO.write(record, \"NC_050871.gbk\", \"genbank\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 handle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\n      2 record = SeqIO.read(handle, \"genbank\")\n      3 SeqIO.write(record, \"NC_050871.gbk\", \"genbank\")\n\nNameError: name 'Entrez' is not defined\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nUsing one of the results from exercise above, download the full record and save it to a file. Then load it from the local file using SeqIO.read.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nhandle = Entrez.efetch(db=\"nucleotide\", id=\"NG_017013.2\", rettype=\"gb\", retmode=\"text\")\n\nSeqIO.read(handle, \"genbank\")\nhandle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\nrecord = SeqIO.read(handle, \"genbank\")\nSeqIO.write(record, \"NG_017013.gbk\", \"genbank\")\n\nprint(record)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 handle = Entrez.efetch(db=\"nucleotide\", id=\"NG_017013.2\", rettype=\"gb\", retmode=\"text\")\n      3 SeqIO.read(handle, \"genbank\")\n      4 handle = Entrez.efetch(db=\"nucleotide\", id=\"NC_050871.1\", rettype=\"gb\", retmode=\"text\")\n\nNameError: name 'Entrez' is not defined",
    "crumbs": [
      "Online databases"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Biopython is a suite of tools for doing computational molecular biology in Python. It has lots of features needed for this kind of work, including:\n\nStandard operations on sequences such as transcription, complements and conversions.\nReading and writing many common file formats such as FASTA, GenBank and Blast.\nQuerying many online databases such as NCBI.\n\nIn this course we wil introduce some of the basics of Biopython and how it can support you in your workflows. It will focus on Biopython as a tool to do your job and less on the specifics of bioinformatics as a research field.\nFor the purpose of this course we will be using a free tool called JupyterLab which provides you with a local editor and Python terminal in your web browser. Setting up instructions can be found here.\n\nIntended learning outcomes\nBy the end of this course, you will:\n\nKnow how to use Biopython\nBe familiar with reading sequencing files\nKnow how to perform simple operations with sequences and alignments\nBe able to query online databases such as NCBI\n\n\n\nHow to read this documentation\nIn this documentation, any time that we are seeing a small snippet of Python code, we’ll see it written in a grey box like the following:\nprint(\"Hello, Python\")\nIf the commands are executed by the machine we will see the output of them below enclosed on a vertical purple line:\n\nprint(\"Hello, Python!\")\n\nHello, Python!\n\n\nBy contrast, you will see larger peces of code as scripts with a given name, e.g. script.py, in a code block with darker header:\n\n\nscript.py\n\ngreeting = \"Hello\"\nname = input(\"What is your name? \")\nprint(greeting, name)\n\nWe may ask you to run a script using the Command Prompt (Windows) or Terminal (Mac and Linux). We will show you what commands to run and will look like this:\n\n\nTerminal/Command Prompt\n\npython script.py\n\nPlease note that sometimes we will skip showing the execution of scripts on the Terminal/Command Prompt box, but we will assume you to run the script on your.\nIn some cases we will introduce general programming concepts and structures using pseudocode, a high-level, easy-to-read syntax close to natural language. This should not be confused with Python code and cannot be executed on your machine, but it is useful to describe how your code should behave. Here there is an example:\nFOR EACH sample IN my_study\n    IF (sample.value &gt; 100)\n        DO SOMETHING\n    OTHERWISE\n        DO SOMETHING ELSE\nThere are some exercises along this course, and it is important you try to answer them yourself to understand how Python works. Exercises are shown in blue boxes followed by a yellow box that contains the answer of each exercise. We recommend you to try to answer each exercise yourself before looking at the solution.\n\n\n\n\n\n\nExercise\n\n\n\nThis is an exercise. You will need to click in the below box to see the answer.\n\n\n\n\n\n\n\n\nAnswer (click to open)\n\n\n\n\n\nThis is the answer.\n\n\n\nLast, we will highlight important points using green boxes like this one:\n\n\n\n\n\n\nKey points\n\n\n\nThese are important concepts and technical notes.",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "pages/200-sequences.html",
    "href": "pages/200-sequences.html",
    "title": "Sequences",
    "section": "",
    "text": "The main class to get to grips with in Biopython is Seq. This is the primary interface to sequence data that you will work with. It is imported as:\n\nfrom Bio.Seq import Seq\n\nOnce you have the Seq class, you can create sequences from standard Python strings:\n\nmy_dna = Seq(\"AGTACACTGGTT\")\n\n\nDNA operations\nOnce you have the DNA in a Seq object, you can perform standard operations on it, such as getting the complement of the sequence:\n\nmy_dna.complement()\n\nSeq('TCATGTGACCAA')\n\n\nand the reverse complement:\n\nmy_dna.reverse_complement()\n\nSeq('AACCAGTGTACT')\n\n\n\n\nRNA\nYou can get the corresponding RNA sequence from a DNA sequence by using the transcribe method:\n\nmy_rna = my_dna.transcribe()\nmy_rna\n\nSeq('AGUACACUGGUU')\n\n\nOnce you have an RNA sequence, you can again do standard operations on it, such as getting the complement:\n\nmy_rna.complement_rna()\n\nSeq('UCAUGUGACCAA')\n\n\nIt is also possible to convert back from an RNA sequence to a DNA sequence:\n\nmy_dna_from_rna = my_rna.back_transcribe()\n\nWhich, if it’s working correctly should give us back the original data:\n\nmy_dna == my_dna_from_rna\n\nTrue\n\n\n\n\nTranslation\nOnce we have an RNA sequence, you can get the expressed protein with translate:\n\nmy_protein = my_rna.translate()\nmy_protein\n\nSeq('STLV')\n\n\n\n\n\n\n\n\nExercise\n\n\n\nGiven a particular sequence\n\nnew_seq = Seq(\"AAATGGCAAAA\")\n\nUse the Biopython documentation to discover how you can count how many time the subsequence AA is present.\nDo you get the count you expect? Can you find the way to count all instances of AA, even those that overlap?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nCounting non-overlapping AA\n\nnew_seq = Seq(\"AAATGGCAAAA\")\nnew_seq.count(Seq(\"AA\"))\n\n3\n\n\nFor an overlapping search of AA\n\nnew_seq = Seq(\"AAATGGCAAAA\")\nnew_seq.count_overlap(\"AA\")\n\n5",
    "crumbs": [
      "Sequences"
    ]
  },
  {
    "objectID": "pages/001-workspace-setup.html",
    "href": "pages/001-workspace-setup.html",
    "title": "Workspace Setup",
    "section": "",
    "text": "Biopython\n\n\n\nIf Biopython is not available in your Python environment, you can install it from the command line/terminal with\npip install -U biopython\n\n\nThis course will use a tool called Jupyter Notebooks to run your Python code. It works with the same Python code as we’ve used before but it allows interactive execution and can combine your code with blocks of text to explain what you’re doing and embed output such as graphs directly into the page.\nThe easiest way to get access to Jupyter Notebooks is to install Anaconda which is a piece of software which includes Python along with lots of other tools. It is freely available for Windows, MacOS and Linux. Anaconda can be installed into your home area on your computer so if you are on a work laptop, for example, you will not need any special permissions. Once Anaconda is installed, start “Anaconda Navigator” and press the JupyterLab button on the main screen:\nThroughout this course you will likely want to start a new notebook for each section of the course so name them appropriately to make it easier to find them later. To open a Notebook in Anaconda you can go to JupyterLab and there go to File &gt; New &gt; Notebook or click the Python 3 button under Notebook section in the Launcher tab.\nOnce the notebook is launched, you will see a wide grey box with a blue [ ]: to the left. The grey box is an input cell where you type any Python code you want to run:\n\n# Python code can be written in 'Code' cells\nprint(\"Output appears below when the cell is run\")\nprint(\"To run a cell, press Ctrl-Enter or Shift-Enter with the cursor inside\")\nprint(\"or use the run button (▶) in the toolbar at the top\")\n\nOutput appears below when the cell is run\nTo run a cell, press Ctrl-Enter or Shift-Enter with the cursor inside\nor use the run button (▶) in the toolbar at the top\n\n\nIn your notebook, type the following in the first cell and then run it with Shift-Enter, you should see the same output:\n\na = 5\nb = 7\na + b\n\n12\n\n\nThe cells in a notebook are linked together so a variable defined in one is available in all the cells from that point on so in the second cell you can use the variables a and b:\n\na - b\n\n-2\n\n\nSome Python libraries have special integration with Jupyter notebooks and so can display their output directly into the page. For example pandas will format tables of data nicely and matplotlib will embed graphs directly:\n\nimport pandas as pd\ntemp = pd.DataFrame(\n    [3.1, 2.4, 4.8, 4.1, 3.4, 4.2],\n    columns=[\"temp (°C)\"],\n    index=pd.RangeIndex(2000, 2006, name=\"year\")\n)\ntemp\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 import pandas as pd\n      2 temp = pd.DataFrame(\n      3     [3.1, 2.4, 4.8, 4.1, 3.4, 4.2],\n      4     columns=[\"temp (°C)\"],\n      5     index=pd.RangeIndex(2000, 2006, name=\"year\")\n      6 )\n      7 temp\n\nModuleNotFoundError: No module named 'pandas'\n\n\n\n\ntemp.plot()\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 temp.plot()\n\nNameError: name 'temp' is not defined\n\n\n\n\nMarkdown\nIf you want to write some text as documentation (like these words here) then you should label the cell as being a Markdown cell. Do that by selecting the cell and going to the dropdown at the top of the page labelled Code and changing it to Markdown.\nIt is becomming common for people to use Jupyter notebooks as a sort of lab notebook where they document their processes, interspersed with code. This style of working where you give prose and code equal weight is sometimes called literate programming.\n\n\n\n\n\n\nExercise\n\n\n\nTake the following code and break it down, chunk by chunk, interspersing it with documentation explaining what each part does using Markdown blocks:\n\nprices = {\n    \"apple\": 0.40,\n    \"banana\": 0.50,\n}\n\nmy_basket = {\n    \"apple\": 1,\n    \"banana\": 6,\n}\n\ntotal_grocery_bill = 0\nfor fruit, count in my_basket.items():\n    total_grocery_bill += prices[fruit] * count\n\nprint(f\"I owe the grocer £{total_grocery_bill:.2f}\")\n\nYou don’t need to put only one line of code per cell, it makes sense sometimes to group some lines together.\nThroughout this course, use the Jupyter Notebook to solve the problems. Follow along with the examples, typing them into your own notebooks and see how they work.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nYour notebook could look similar to:\n\nMy first notebook\nWe first define the price of apples and bananas.\n\nprices = {\n    \"apple\": 0.40,\n    \"banana\": 0.50,\n}\n\nThen we state how many apples and bananas we have in the basket.\n\nmy_basket = {\n    \"apple\": 1,\n    \"banana\": 6,\n}\n\nFor each fruit in the basket we calculate the price to pay and add it to the total bill.\n\ntotal_grocery_bill = 0\nfor fruit, count in my_basket.items():\n    total_grocery_bill += prices[fruit] * count\n\nWe print a message with the total owed to the shop.\n\nprint(f\"I owe the grocer £{total_grocery_bill:.2f}\")\n\nI owe the grocer £3.40",
    "crumbs": [
      "Workspace Setup"
    ]
  },
  {
    "objectID": "pages/300-input-output.html",
    "href": "pages/300-input-output.html",
    "title": "Input and Output",
    "section": "",
    "text": "In this section we’ll be looking at the functionality that Biopython provides for reading and writing files. This is all handled by the Bio.SeqIO module so let’s start by importing it:\n\nfrom Bio import SeqIO\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 1\n----&gt; 1 from Bio import SeqIO\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\n\nFiles for this section\nFor this section you need to download some files which we will be reading in. You can either download them by hand from using these links: V01408.1.fasta, ls_orchid_short.gbk and ls_orchid.gbk or run the following Python code:\nimport urllib\nfor f in [\"V01408.1.fasta\", \"ls_orchid_short.fasta\", \"ls_orchid.gbk\"]:\n    urllib.request.urlretrieve(f\"https://bristol-training.github.io/introduction-to-biopython/data/{f}\", f)\n\n\nSeqRecord objects\nIf you have a FASTA file with a single sequence in it, the simplest way to read it in is with SeqIO.read. This takes two arguments, the name of the file you want to open, and the format that file is in.\n\n\n\n\n\n\nFASTA file format\n\n\n\nFASTA files can contain multiple sequences, each begining with a description line, starting with a “&gt;” symbol.\n&gt;Sequence1\nATCGATCGATCGATCGACTGACTAGCTAACG\nCAGTCAGTCAGTCAGTCAGTCAGTCAGTCAG\nAGTCAGTCAGTCAGTCAGTCAGT\n\n&gt;Sequence2\nACTGACTAGCTAACGCAGTCAGTCAGTCAGT\nCAGTCAGTCAGTCAGTCAGAGTCAGTCAGTC\nAGTCAGTCAGTCATCGATCGATCGATCGACT\n\n\n\ntm = SeqIO.read(\"V01408.1.fasta\", \"fasta\")\nprint(tm)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[2], line 1\n----&gt; 1 tm = SeqIO.read(\"V01408.1.fasta\", \"fasta\")\n      2 print(tm)\n\nNameError: name 'SeqIO' is not defined\n\n\n\nThe read functions returns an object called a SeqRecord. These are like the Seqs that we saw before but have additional information associated with them. A full list of these are:\n\n\n.seq\n\nThe sequence itself, typically a Seq object as we saw in the last chapter.\n\n.id\n\nThe primary ID used to identify the sequence.\n\n.name\n\nA “common” name/id for the sequence. In some cases this will be the same as the ID, but it could also be a clone name.\n\n.description\n\nA human readable description or expressive name for the sequence.\n\n.letter_annotations\n\nHolds per-letter-annotations using a (restricted) dictionary of additional information about the letters in the sequence. The keys are the name of the information, and the information is contained in the value as a Python sequence (i.e. a list, tuple or string) with the same length as the sequence itself. This is often used for quality scores or secondary structure information (e.g. from alignment files).\n\n.annotations\n\nA dictionary of additional information about the sequence. The keys are the name of the information, and the information is contained in the value. This allows the addition of more “unstructured” information to the sequence.\n\n.features\n\nA list of SeqFeature objects with more structured information about the features on a sequence (e.g. position of genes on a genome, or domains on a protein sequence).\n\n.dbxrefs\n\nA list of database cross-references as strings.\n\nSo you can get the Seq object fom inside the record with:\n\ntm.seq\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 tm.seq\n\nNameError: name 'tm' is not defined\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at the value of some of these attributes of the tm object. Which are available and which are missing or empty?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ntm.seq\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[4], line 1\n----&gt; 1 tm.seq\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.id\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[5], line 1\n----&gt; 1 tm.id\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.name\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[6], line 1\n----&gt; 1 tm.name\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.description\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 tm.description\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.letter_annotations\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 tm.letter_annotations\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.annotations\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[9], line 1\n----&gt; 1 tm.annotations\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.features\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[10], line 1\n----&gt; 1 tm.features\n\nNameError: name 'tm' is not defined\n\n\n\n\ntm.dbxrefs\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 tm.dbxrefs\n\nNameError: name 'tm' is not defined\n\n\n\n\n\n\n\n\nReading in multiple sequences\nIt is very common to have files which contain multiple sequences. Biopython provides an interface to read these in, one after another which is the SeqIO.parse function. This provides you with an object which you can loop over with a for loop:\n\nfor record in SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"):\n    print(record.description)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[12], line 1\n----&gt; 1 for record in SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"):\n      2     print(record.description)\n\nNameError: name 'SeqIO' is not defined\n\n\n\nEach time around the loop, you are given a SeqRecord object which will work in exactly the same way as in the previous section, so getting the .description works fine.\n\n\n\n\n\n\nExercise\n\n\n\nLoad in the ls_orchid_short.fasta file and print out the length of each sequence, along with its description.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfor record in SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"):\n    print(len(record.seq), \" -\", record.description)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[13], line 1\n----&gt; 1 for record in SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"):\n      2     print(len(record.seq), \" -\", record.description)\n\nNameError: name 'SeqIO' is not defined\n\n\n\n\n\n\nThe type of the object returned by SeqIO.parse is known as a generator. One of the features of a generator in Python is that you can only loop over them once before they are exhausted. For example you can loop over them once without issue:\n\nrecords = SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\")\nprint([r.id for r in records])\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[14], line 1\n----&gt; 1 records = SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\")\n      2 print([r.id for r in records])\n\nNameError: name 'SeqIO' is not defined\n\n\n\nBut if you try to use the same object again, you will see that you get nothing back:\n\nprint([r.id for r in records])\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[15], line 1\n----&gt; 1 print([r.id for r in records])\n\nNameError: name 'records' is not defined\n\n\n\nThe reason for this is that it allows you to access, one at a time, a very long list of sequences, potentially more than can fit in memory at once since it only loads them one at a time.\nIf you know you have a short set of sequences (as we have in this tutorial) then you can load them all into a Python list and access them however you wish:\n\nrecords = list(SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"))\nprint([r.id for r in records])\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[16], line 1\n----&gt; 1 records = list(SeqIO.parse(\"ls_orchid_short.fasta\", \"fasta\"))\n      2 print([r.id for r in records])\n\nNameError: name 'SeqIO' is not defined\n\n\n\n\nprint([r.id for r in records])\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[17], line 1\n----&gt; 1 print([r.id for r in records])\n\nNameError: name 'records' is not defined\n\n\n\n\n\nGenbank files\nAs well as FASTA files, Biopython can read GenBank files. All you need to do is specify the filetype when calling the SeqIO.parse function. If you pass \"genbank\" (or \"gb\") as the second argument then it will read it as a GenBankfile:\n\nrecord_iterator = SeqIO.parse(\"ls_orchid.gbk\", \"genbank\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[18], line 1\n----&gt; 1 record_iterator = SeqIO.parse(\"ls_orchid.gbk\", \"genbank\")\n\nNameError: name 'SeqIO' is not defined\n\n\n\nIf you are loading a file with multiple sequences in, you can grab just the first one with Python’s next function. This gives you whatever would be available the first time around the loop:\n\nfirst_record = next(record_iterator)\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[19], line 1\n----&gt; 1 first_record = next(record_iterator)\n\nNameError: name 'record_iterator' is not defined\n\n\n\nGenBank files usually contain a lot more information than a FASTA so more of the fields of the SeqRecord will be filled in. This means that we can, for example, see the annotations that the sequecne has:\n\nfirst_record.annotations\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[20], line 1\n----&gt; 1 first_record.annotations\n\nNameError: name 'first_record' is not defined\n\n\n\n\n\n\n\n\n\nExercise\n\n\n\nTake a look at the record and see what other SeqRecord attributes are filled in which were missing from the FASTA file we loaded earlier.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nfirst_record.seq\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[21], line 1\n----&gt; 1 first_record.seq\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.id\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[22], line 1\n----&gt; 1 first_record.id\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.name\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[23], line 1\n----&gt; 1 first_record.name\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.description\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[24], line 1\n----&gt; 1 first_record.description\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.letter_annotations\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 first_record.letter_annotations\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.annotations\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[26], line 1\n----&gt; 1 first_record.annotations\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.features\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[27], line 1\n----&gt; 1 first_record.features\n\nNameError: name 'first_record' is not defined\n\n\n\n\nfirst_record.dbxrefs\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[28], line 1\n----&gt; 1 first_record.dbxrefs\n\nNameError: name 'first_record' is not defined\n\n\n\n\n\n\nWe’ve talked about using Bio.SeqIO.parse for sequence input (reading files), and now we’ll look at Bio.SeqIO.write which is for sequence output (writing files). This is a function taking three arguments: some SeqRecord objects, a handle or filename to write to, and a sequence format.\nHere is an example, where we start by creating a few SeqRecord objects the hard way (by hand, rather than by loading them from a file):\n\nfrom Bio.Seq import Seq\nfrom Bio.SeqRecord import SeqRecord\n\nrec1 = SeqRecord(\n    Seq(\n        \"MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD\"\n        \"GAGAVIVGSDPDLSVERPLYELVWTGATLLPDSEGAIDGHLREVGLTFHLLKDVPGLISK\"\n        \"NIEKSLKEAFTPLGISDWNSTFWIAHPGGPAILDQVEAKLGLKEEKMRATREVLSEYGNM\"\n        \"SSAC\",\n    ),\n    id=\"gi|14150838|gb|AAK54648.1|AF376133_1\",\n    description=\"chalcone synthase [Cucumis sativus]\",\n)\n\nrec2 = SeqRecord(\n    Seq(\n        \"YPDYYFRITNREHKAELKEKFQRMCDKSMIKKRYMYLTEEILKENPSMCEYMAPSLDARQ\"\n        \"DMVVVEIPKLGKEAAVKAIKEWGQ\",\n    ),\n    id=\"gi|13919613|gb|AAK33142.1|\",\n    description=\"chalcone synthase [Fragaria vesca subsp. bracteata]\",\n)\n\nmy_records = [rec1, rec2]\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[29], line 1\n----&gt; 1 from Bio.Seq import Seq\n      2 from Bio.SeqRecord import SeqRecord\n      4 rec1 = SeqRecord(\n      5     Seq(\n      6         \"MMYQQGCFAGGTVLRLAKDLAENNRGARVLVVCSEITAVTFRGPSETHLDSMVGQALFGD\"\n   (...)\n     12     description=\"chalcone synthase [Cucumis sativus]\",\n     13 )\n\nModuleNotFoundError: No module named 'Bio'\n\n\n\nNow we have a list of SeqRecord objects, we’ll write them to a FASTA format file:\n\nSeqIO.write(my_records, \"my_example.faa\", \"fasta\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[30], line 1\n----&gt; 1 SeqIO.write(my_records, \"my_example.faa\", \"fasta\")\n\nNameError: name 'SeqIO' is not defined\n\n\n\nThe 2 that gets returned tells you how many records were written.\n\n\n\n\n\n\nExercise\n\n\n\nCreate one SeqRecord by hand and write it to a .gbk file. Then read that file in and check that the details match.",
    "crumbs": [
      "Input and Output"
    ]
  }
]